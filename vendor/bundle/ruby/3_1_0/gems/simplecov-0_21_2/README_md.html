<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>README - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../../../../";
  var index_rel_prefix = "../../../../../../";
</script>

<script src="../../../../../../js/navigation.js" defer></script>
<script src="../../../../../../js/search.js" defer></script>
<script src="../../../../../../js/search_index.js" defer></script>
<script src="../../../../../../js/searcher.js" defer></script>
<script src="../../../../../../js/darkfish.js" defer></script>

<link href="../../../../../../css/fonts.css" rel="stylesheet">
<link href="../../../../../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-SimpleCov+rdoc-image-3Ahttps-3A-2F-2Fbadge.fury.io-2Frb-2Fsimplecov.svg+rdoc-image-3Ahttps-3A-2F-2Fgithub.com-2Fsimplecov-ruby-2Fsimplecov-2Fworkflows-2Fstable-2Fbadge.svg-3Fbranch-3Dmain+rdoc-image-3Ahttps-3A-2F-2Fapi.codeclimate.com-2Fv1-2Fbadges-2Fc071d197d61953a7e482-2Fmaintainability+rdoc-image-3Ahttp-3A-2F-2Finch-ci.org-2Fgithub-2Fsimplecov-ruby-2Fsimplecov.svg-3Fbranch-3Dmain">SimpleCov <a href="https://badge.fury.io/rb/simplecov"><img src="https://badge.fury.io/rb/simplecov.svg"></a> <a href="https://github.com/simplecov-ruby/simplecov/actions?query=workflow%3Astable"><img src="https://github.com/simplecov-ruby/simplecov/workflows/stable/badge.svg?branch=main"></a> <a href="https://codeclimate.com/github/simplecov-ruby/simplecov/maintainability"><img src="https://api.codeclimate.com/v1/badges/c071d197d61953a7e482/maintainability"></a> <a href="http://inch-ci.org/github/simplecov-ruby/simplecov"><img src="http://inch-ci.org/github/simplecov-ruby/simplecov.svg?branch=main"></a></a>
    <li><a href="#label-Contact">Contact</a>
    <li><a href="#label-Getting+started">Getting started</a>
    <li><a href="#label-Example+output">Example output</a>
    <li><a href="#label-Use+it+with+any+framework-21">Use it with any framework!</a>
    <li><a href="#label-Notes+on+specific+frameworks+and+test+utilities">Notes on specific frameworks and test utilities</a>
    <li><a href="#label-Configuring+SimpleCov">Configuring SimpleCov</a>
    <li><a href="#label-Using+.simplecov+for+centralized+config">Using .simplecov for centralized config</a>
    <li><a href="#label-Branch+coverage+-28ruby+-22~-3E+2.5-22-29">Branch coverage (ruby “~&gt; 2.5”)</a>
    <li><a href="#label-Primary+Coverage">Primary Coverage</a>
    <li><a href="#label-Filters">Filters</a>
    <li><a href="#label-Defining+custom+filters">Defining custom filters</a>
    <li><a href="#label-String+filter">String filter</a>
    <li><a href="#label-Regex+filter">Regex filter</a>
    <li><a href="#label-Block+filter">Block filter</a>
    <li><a href="#label-Custom+filter+class">Custom filter class</a>
    <li><a href="#label-Array+filter">Array filter</a>
    <li><a href="#label-Ignoring-2Fskipping+code">Ignoring/skipping code</a>
    <li><a href="#label-Default+root+filter+and+coverage+for+things+outside+of+it">Default root filter and coverage for things outside of it</a>
    <li><a href="#label-Groups">Groups</a>
    <li><a href="#label-Merging+results">Merging results</a>
    <li><a href="#label-Test+suite+names">Test suite names</a>
    <li><a href="#label-Merging+test+runs+under+the+same+execution+environment">Merging test runs under the same execution environment</a>
    <li><a href="#label-Timeout+for+merge">Timeout for merge</a>
    <li><a href="#label-Merging+test+runs+under+different+execution+environments">Merging test runs under different execution environments</a>
    <li><a href="#label-Running+simplecov+against+subprocesses">Running simplecov against subprocesses</a>
    <li><a href="#label-Running+simplecov+against+spawned+subprocesses">Running simplecov against spawned subprocesses</a>
    <li><a href="#label-Running+coverage+only+on+demand">Running coverage only on demand</a>
    <li><a href="#label-Errors+and+exit+statuses">Errors and exit statuses</a>
    <li><a href="#label-Profiles">Profiles</a>
    <li><a href="#label-Custom+profiles">Custom profiles</a>
    <li><a href="#label-Customizing+exit+behaviour">Customizing exit behaviour</a>
    <li><a href="#label-Minimum+coverage">Minimum coverage</a>
    <li><a href="#label-Minimum+coverage+by+file">Minimum coverage by file</a>
    <li><a href="#label-Maximum+coverage+drop">Maximum coverage drop</a>
    <li><a href="#label-Refuse+dropping+coverage">Refuse dropping coverage</a>
    <li><a href="#label-Using+your+own+formatter">Using your own formatter</a>
    <li><a href="#label-Using+multiple+formatters">Using multiple formatters</a>
    <li><a href="#label-JSON+formatter">JSON formatter</a>
    <li><a href="#label-Available+formatters-2C+editor+integrations+and+hosted+services">Available formatters, editor integrations and hosted services</a>
    <li><a href="#label-Ruby+version+compatibility">Ruby version compatibility</a>
    <li><a href="#label-Want+to+find+dead+code+in+production-3F">Want to find dead code in production?</a>
    <li><a href="#label-Want+to+use+Spring+with+SimpleCov-3F">Want to use Spring with SimpleCov?</a>
    <li><a href="#label-Troubleshooting">Troubleshooting</a>
    <li><a href="#label-Code+of+Conduct">Code of Conduct</a>
    <li><a href="#label-Contributing">Contributing</a>
    <li><a href="#label-Kudos">Kudos</a>
    <li><a href="#label-Copyright">Copyright</a>
  </ul>
</div>


  <div id="project-metadata">
    
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../../../../../CHANGELOG_md.html">CHANGELOG</a>
    <li><a href="../../../../../../CODE_OF_CONDUCT_md.html">CODE_OF_CONDUCT</a>
    <li><a href="../../../../../../Gemfile.html">Gemfile</a>
    <li><a href="../../../../../../Gemfile_lock.html">Gemfile.lock</a>
    <li><a href="../../../../../../LICENSE.html">LICENSE</a>
    <li><a href="../../../../../../README_md.html">README</a>
    <li><a href="../../../../../../Rakefile.html">Rakefile</a>
    <li><a href="../../../../../../bin/setup.html">setup</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/bin/stackprof-flamegraph_pl.html">stackprof-flamegraph.pl</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/bin/stackprof-gprof2dot_py.html">stackprof-gprof2dot.py</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/extensions/x86_64-linux/3_1_0/stackprof-0_2_19/gem_build_complete.html">gem.build_complete</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/extensions/x86_64-linux/3_1_0/stackprof-0_2_19/gem_make_out.html">gem_make.out</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/extensions/x86_64-linux/3_1_0/stackprof-0_2_19/mkmf_log.html">mkmf.log</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/ast-2_4_2/LICENSE_MIT.html">LICENSE.MIT</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/ast-2_4_2/README_YARD_md.html">README.YARD</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/benchmark-ips-2_10_0/History_md.html">History</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/benchmark-ips-2_10_0/LICENSE.html">LICENSE</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/benchmark-ips-2_10_0/README_md.html">README</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/docile-1_4_0/Gemfile.html">Gemfile</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/docile-1_4_0/HISTORY_md.html">HISTORY</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/docile-1_4_0/LICENSE.html">LICENSE</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/docile-1_4_0/README_md.html">README</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/docile-1_4_0/Rakefile.html">Rakefile</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/docile-1_4_0/SECURITY_md.html">SECURITY</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/minitest-5_15_0/History_rdoc.html">History</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/minitest-5_15_0/Manifest_txt.html">Manifest</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/minitest-5_15_0/README_rdoc.html">README</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/minitest-5_15_0/Rakefile.html">Rakefile</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/parser-3_1_1_0/LICENSE_txt.html">LICENSE</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/rake-13_0_6/History_rdoc.html">History</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/rake-13_0_6/MIT-LICENSE.html">MIT-LICENSE</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/rake-13_0_6/README_rdoc.html">README</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/rake-13_0_6/doc/command_line_usage_rdoc.html">command_line_usage</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/rake-13_0_6/doc/example/Rakefile1.html">Rakefile1</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/rake-13_0_6/doc/example/Rakefile2.html">Rakefile2</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/rake-13_0_6/doc/glossary_rdoc.html">glossary</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/rake-13_0_6/doc/proto_rake_rdoc.html">proto_rake</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/rake-13_0_6/doc/rake_1.html">rake.1</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/rake-13_0_6/doc/rakefile_rdoc.html">rakefile</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/rake-13_0_6/doc/rational_rdoc.html">rational</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/ruby_parser-3_18_1/History_rdoc.html">History</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/ruby_parser-3_18_1/Manifest_txt.html">Manifest</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/ruby_parser-3_18_1/README_rdoc.html">README</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/ruby_parser-3_18_1/Rakefile.html">Rakefile</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/ruby_parser-3_18_1/debugging_md.html">debugging</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/ruby_parser-3_18_1/gauntlet_md.html">gauntlet</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/sexp_processor-4_16_0/History_rdoc.html">History</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/sexp_processor-4_16_0/Manifest_txt.html">Manifest</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/sexp_processor-4_16_0/README_rdoc.html">README</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/sexp_processor-4_16_0/Rakefile.html">Rakefile</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/simplecov-0_21_2/CHANGELOG_md.html">CHANGELOG</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/simplecov-0_21_2/LICENSE.html">LICENSE</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/simplecov-0_21_2/README_md.html">README</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/simplecov-0_21_2/doc/alternate-formatters_md.html">alternate-formatters</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/simplecov-0_21_2/doc/commercial-services_md.html">commercial-services</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/simplecov-0_21_2/doc/editor-integration_md.html">editor-integration</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/simplecov-html-0_12_3/LICENSE.html">LICENSE</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/simplecov_json_formatter-0_1_3/CHANGELOG_md.html">CHANGELOG</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/simplecov_json_formatter-0_1_3/README_md.html">README</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/CHANGELOG_md.html">CHANGELOG</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/Gemfile.html">Gemfile</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/LICENSE.html">LICENSE</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/README_md.html">README</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/Rakefile.html">Rakefile</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/bin/stackprof-flamegraph_pl.html">stackprof-flamegraph.pl</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/bin/stackprof-gprof2dot_py.html">stackprof-gprof2dot.py</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/ext/stackprof/Makefile.html">Makefile</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/lib/stackprof/flamegraph/flamegraph_js.html">flamegraph.js</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/lib/stackprof/flamegraph/viewer_html.html">viewer.html</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/vendor/FlameGraph/README.html">README</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/vendor/FlameGraph/flamegraph_pl.html">flamegraph.pl</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/vendor/gprof2dot/gprof2dot_py.html">gprof2dot.py</a>
    <li><a href="../../../../../../vendor/bundle/ruby/3_1_0/gems/stackprof-0_2_19/vendor/gprof2dot/hotshotmain_py.html">hotshotmain.py</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page vendor/bundle/ruby/3.1.0/gems/simplecov-0.21.2/README.md">

<h1 id="label-SimpleCov+rdoc-image-3Ahttps-3A-2F-2Fbadge.fury.io-2Frb-2Fsimplecov.svg+rdoc-image-3Ahttps-3A-2F-2Fgithub.com-2Fsimplecov-ruby-2Fsimplecov-2Fworkflows-2Fstable-2Fbadge.svg-3Fbranch-3Dmain+rdoc-image-3Ahttps-3A-2F-2Fapi.codeclimate.com-2Fv1-2Fbadges-2Fc071d197d61953a7e482-2Fmaintainability+rdoc-image-3Ahttp-3A-2F-2Finch-ci.org-2Fgithub-2Fsimplecov-ruby-2Fsimplecov.svg-3Fbranch-3Dmain"><a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> <a href="https://badge.fury.io/rb/simplecov"><img src="https://badge.fury.io/rb/simplecov.svg"></a> <a href="https://github.com/simplecov-ruby/simplecov/actions?query=workflow%3Astable"><img src="https://github.com/simplecov-ruby/simplecov/workflows/stable/badge.svg?branch=main"></a> <a href="https://codeclimate.com/github/simplecov-ruby/simplecov/maintainability"><img src="https://api.codeclimate.com/v1/badges/c071d197d61953a7e482/maintainability"></a> <a href="http://inch-ci.org/github/simplecov-ruby/simplecov"><img src="http://inch-ci.org/github/simplecov-ruby/simplecov.svg?branch=main"></a><span><a href="#label-SimpleCov+rdoc-image-3Ahttps-3A-2F-2Fbadge.fury.io-2Frb-2Fsimplecov.svg+rdoc-image-3Ahttps-3A-2F-2Fgithub.com-2Fsimplecov-ruby-2Fsimplecov-2Fworkflows-2Fstable-2Fbadge.svg-3Fbranch-3Dmain+rdoc-image-3Ahttps-3A-2F-2Fapi.codeclimate.com-2Fv1-2Fbadges-2Fc071d197d61953a7e482-2Fmaintainability+rdoc-image-3Ahttp-3A-2F-2Finch-ci.org-2Fgithub-2Fsimplecov-ruby-2Fsimplecov.svg-3Fbranch-3Dmain">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><strong>Code coverage for Ruby</strong></p>
<ul><li>
<p><a href="https://github.com/simplecov-ruby/simplecov">Source Code</a></p>
</li><li>
<p><a href="http://rubydoc.info/gems/simplecov/frames">API documentation</a></p>
</li><li>
<p><a href="https://github.com/simplecov-ruby/simplecov/blob/main/CHANGELOG.md">Changelog</a></p>
</li><li>
<p><a href="http://rubygems.org/gems/simplecov">Rubygem</a></p>
</li><li>
<p><a href="https://github.com/simplecov-ruby/simplecov/actions?query=workflow%3Astable">Continuous Integration</a></p>
</li></ul>

<p><a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> is a code coverage analysis tool for Ruby. It uses <a href="https://ruby-doc.org/stdlib/libdoc/coverage/rdoc/Coverage.html">Ruby’s built-in Coverage</a> library to gather code coverage data, but makes processing its results much easier by providing a clean API to filter, group, merge, format, and display those results, giving you a complete code coverage suite that can be set up with just a couple lines of code. SimpleCov/Coverage track covered ruby code, gathering coverage for common templating solutions like erb, slim and haml is not supported.</p>

<p>In most cases, you’ll want overall coverage results for your projects, including all types of tests, Cucumber features, etc. <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> automatically takes care of this by caching and merging results when generating reports, so your report actually includes coverage across your test suites and thereby gives you a better picture of blank spots.</p>

<p>The official formatter of <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> is packaged as a separate gem called <a href="https://github.com/simplecov-ruby/simplecov-html">simplecov-html</a>, but will be installed and configured automatically when you launch <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a>. If you’re curious, you can find it <a href="https://github.com/simplecov-ruby/simplecov-html">on GitHub, too</a>.</p>

<h2 id="label-Contact">Contact<span><a href="#label-Contact">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><em>Code and Bug Reports</em></p>
<ul><li>
<p><a href="https://github.com/simplecov-ruby/simplecov/issues">Issue Tracker</a></p>
</li><li>
<p>See <a href="https://github.com/simplecov-ruby/simplecov/blob/main/CONTRIBUTING.md">CONTRIBUTING</a> for how to contribute along with some common problems to check out before creating an issue.</p>
</li></ul>

<p><em>Questions, Problems, Suggestions, etc.</em></p>
<ul><li>
<p><a href="https://groups.google.com/forum/#!forum/simplecov">Mailing List</a> “Open mailing list for discussion and announcements on Google Groups”</p>
</li></ul>

<h2 id="label-Getting+started">Getting started<span><a href="#label-Getting+started">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ol><li>
<p>Add <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> to your <code>Gemfile</code> and <code>bundle install</code>:</p>

<pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-string">&#39;simplecov&#39;</span>, <span class="ruby-value">require:</span> <span class="ruby-keyword">false</span>, <span class="ruby-value">group:</span> <span class="ruby-value">:test</span>
</pre>
</li><li>
<p>Load and launch <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> <strong>at the very top</strong> of your <code>test/test_helper.rb</code>  (<em>or <code>spec_helper.rb</code>, <code>rails_helper</code>, cucumber <code>env.rb</code>, or whatever your preferred test  framework uses</em>):</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov&#39;</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span>

<span class="ruby-comment"># Previous content of test helper now starts here</span>
</pre>

<p><strong>Note:</strong> If <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> starts after your application code is already loaded (via <code>require</code>), it won’t be able to track your files and their coverage! The <code>SimpleCov.start</code> <strong>must</strong> be issued <strong>before any of your application code is required!</strong></p>

<p><a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> must be running in the process that you want the code coverage analysis to happen on. When testing a server process (e.g. a JSON API endpoint) via a separate test process (e.g. when using Selenium) where you want to see all code executed by the <code>rails server</code>, and not just code executed in your actual test files, you need to require <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> in the server process. For rails for instance, you’ll want to add something like this to the top of <code>bin/rails</code>, but below the “shebang” line (<code>#! /usr/bin/env ruby</code>) and after config/boot is required:</p>

<pre class="ruby"><span class="ruby-keyword">if</span> <span class="ruby-constant">ENV</span>[<span class="ruby-string">&#39;RAILS_ENV&#39;</span>] <span class="ruby-operator">==</span> <span class="ruby-string">&#39;test&#39;</span>
  <span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov&#39;</span>
  <span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-string">&#39;rails&#39;</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;required simplecov&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
</li><li>
<p>Run your full test suite to see the percent coverage that your application has.</p>
</li><li>
<p>After running your tests, open <code>coverage/index.html</code> in the browser of your choice. For example, in a Mac Terminal,  run the following command from your application's root directory:</p>
</li></ol>

<p><code>    open coverage/index.html </code>  in a debian/ubuntu Terminal,</p>

<p><code>    xdg-open coverage/index.html </code></p>

<p><strong>Note:</strong> <a href="https://dwheeler.com/essays/open-files-urls.html">This guide</a> can help if you’re unsure which command your particular  operating system requires.</p>
<ol><li>
<p>Add the following to your <code>.gitignore</code> file to ensure that coverage results  are not tracked by Git (optional):</p>
</li></ol>

<p><code>    echo &quot;coverage&quot; &gt;&gt; .gitignore </code>  Or if you use Windows:  <code>    echo coverage &gt;&gt; .gitignore </code></p>

<p>If you’re making a Rails application, <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> comes with built-in configurations (see below for information on  profiles) that will get you started with groups for your Controllers, Models and Helpers. To use it, the  first two lines of your test_helper should be like this:</p>

<p><code>ruby    require &#39;simplecov&#39;    SimpleCov.start &#39;rails&#39; </code></p>

<h2 id="label-Example+output">Example output<span><a href="#label-Example+output">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><strong>Coverage results report, fully browsable locally with sorting and much more:</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/137793/17071162/db6f253e-502d-11e6-9d84-e40c3d75f333.png"></p>

<p><strong>Source file coverage details view:</strong></p>

<p><img src="https://cloud.githubusercontent.com/assets/137793/17071163/db6f9f0a-502d-11e6-816c-edb2c66fad8d.png"></p>

<h2 id="label-Use+it+with+any+framework-21">Use it with any framework!<span><a href="#label-Use+it+with+any+framework-21">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Similarly to the usage with Test::Unit described above, the only thing you have to do is to add the <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> config to the very top of your Cucumber/RSpec/whatever setup file.</p>

<p>Add the setup code to the <strong>top</strong> of <code>features/support/env.rb</code> (for Cucumber) or <code>spec/spec_helper.rb</code> (for RSpec). Other test frameworks should work accordingly, whatever their setup file may be:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov&#39;</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-string">&#39;rails&#39;</span>
</pre>

<p>You could even track what kind of code your UI testers are touching if you want to go overboard with things. <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> does not care what kind of framework it is running in; it just looks at what code is being executed and generates a report about it.</p>

<h3 id="label-Notes+on+specific+frameworks+and+test+utilities">Notes on specific frameworks and test utilities<span><a href="#label-Notes+on+specific+frameworks+and+test+utilities">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>For some frameworks and testing tools there are quirks and problems you might want to know about if you want to use <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> with them. Here's an overview of the known ones:</p>
<table>
  <tr><th>Framework</th><th>Notes</th><th>Issue</th></tr>
  <tr>
    <th>
      parallel_tests
    </th>
    <td>
      As of 0.8.0, SimpleCov should correctly recognize parallel_tests and
      supplement your test suite names with their corresponding test env
      numbers. SimpleCov locks the resultset cache while merging, ensuring no
      race conditions occur when results are merged.
    </td>
    <td>
      <a href="https://github.com/simplecov-ruby/simplecov/issues/64">#64</a> &amp;
      <a href="https://github.com/simplecov-ruby/simplecov/pull/185">#185</a>
    </td>
  </tr>
  <tr>
    <th>
      knapsack_pro
    </th>
    <td>
      To make SimpleCov work with Knapsack Pro Queue Mode to split tests in parallel on CI jobs you need to provide CI node index number to the <code>SimpleCov.command_name</code> in <code>KnapsackPro::Hooks::Queue.before_queue</code> hook.
    </td>
    <td>
      <a href="https://knapsackpro.com/faq/question/how-to-use-simplecov-in-queue-mode">Tip</a>
    </td>
  </tr>
  <tr>
    <th>
      RubyMine
    </th>
    <td>
      The <a href="https://www.jetbrains.com/ruby/">RubyMine IDE</a> has
      built-in support for SimpleCov's coverage reports, though you might need
      to explicitly set the output root using `SimpleCov.root('foo/bar/baz')`
    </td>
    <td>
      <a href="https://github.com/simplecov-ruby/simplecov/issues/95">#95</a>
    </td>
  </tr>
  <tr>
    <th>
      Spork
    </th>
    <td>
      Because of how Spork works internally (using preforking), there used to
      be trouble when using SimpleCov with it, but that has apparently been
      resolved with a specific configuration strategy. See <a
      href="https://github.com/simplecov-ruby/simplecov/issues/42#issuecomment-4440284">this</a>
      comment.
    </td>
    <td>
      <a href="https://github.com/simplecov-ruby/simplecov/issues/42#issuecomment-4440284">#42</a>
    </td>
  </tr>
  <tr>
    <th>
      Spring
    </th>
    <td>
      <a href="#want-to-use-spring-with-simplecov">See section below.</a>
    </td>
    <td>
      <a href="https://github.com/simplecov-ruby/simplecov/issues/381">#381</a>
    </td>
  </tr>
  <tr>
    <th>
      Test/Unit
    </th>
    <td>
      Test Unit 2 used to mess with ARGV, leading to a failure to detect the
      test process name in SimpleCov. <code>test-unit</code> releases 2.4.3+
      (Dec 11th, 2011) should have this problem resolved.
    </td>
    <td>
      <a href="https://github.com/simplecov-ruby/simplecov/issues/45">#45</a> &amp;
      <a href="https://github.com/test-unit/test-unit/pull/12">test-unit/test-unit#12</a>
    </td>
  </tr>
</table>
<h2 id="label-Configuring+SimpleCov">Configuring <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a><span><a href="#label-Configuring+SimpleCov">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="http://rubydoc.info/gems/simplecov/SimpleCov/Configuration">Configuration</a> settings can be applied in three formats, which are completely equivalent:</p>
<ul><li>
<p>The most common way is to configure it directly in your start block:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">some_config_option</span> <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-keyword">end</span>
</pre>
</li><li>
<p>You can also set all configuration options directly:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">some_config_option</span> <span class="ruby-string">&#39;foo&#39;</span>
</pre>
</li><li>
<p>If you do not want to start coverage immediately after launch or want to add additional configuration later on in a  concise way, use:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">configure</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">some_config_option</span> <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-keyword">end</span>
</pre>
</li></ul>

<p>Please check out the <a href="http://rubydoc.info/gems/simplecov/SimpleCov/Configuration">Configuration</a> API documentation to find out what you can customize.</p>

<h2 id="label-Using+.simplecov+for+centralized+config">Using .simplecov for centralized config<span><a href="#label-Using+.simplecov+for+centralized+config">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If you use <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> to merge multiple test suite results (e.g. Test/Unit and Cucumber) into a single report, you’d normally have to set up all your config options twice, once in <code>test_helper.rb</code> and once in <code>env.rb</code>.</p>

<p>To avoid this, you can place a file called <code>.simplecov</code> in your project root. You can then just leave the <code>require &#39;simplecov&#39;</code> in each test setup helper (<strong>at the top</strong>) and move the <code>SimpleCov.start</code> code with all your custom config options into <code>.simplecov</code>:</p>

<pre class="ruby"><span class="ruby-comment"># test/test_helper.rb</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov&#39;</span>

<span class="ruby-comment"># features/support/env.rb</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov&#39;</span>

<span class="ruby-comment"># .simplecov</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-string">&#39;rails&#39;</span> <span class="ruby-keyword">do</span>
  <span class="ruby-comment"># any custom configs like groups and filters can be here at a central place</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Using <code>.simplecov</code> rather than separately requiring <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> multiple times is recommended if you are merging multiple test frameworks like Cucumber and RSpec that rely on each other, as invoking <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> multiple times can cause coverage information to be lost.</p>

<h2 id="label-Branch+coverage+-28ruby+-22~-3E+2.5-22-29">Branch coverage (ruby “~&gt; 2.5”)<span><a href="#label-Branch+coverage+-28ruby+-22~-3E+2.5-22-29">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Add branch coverage measurement statistics to your results. Supported in CRuby versions 2.5+.</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">enable_coverage</span> <span class="ruby-value">:branch</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Branch coverage is a feature introduced in Ruby 2.5 concerning itself with whether a particular branch of a condition had been executed. Line coverage on the other hand is only interested in whether a line of code has been executed.</p>

<p>This comes in handy for instance for one line conditionals:</p>

<pre class="ruby"><span class="ruby-identifier">number</span>.<span class="ruby-identifier">odd?</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;odd&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&quot;even&quot;</span>
</pre>

<p>In line coverage this line would always be marked as executed but you’d never know if both conditions were met. Guard clauses have a similar story:</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">number</span>.<span class="ruby-identifier">odd?</span>

<span class="ruby-comment"># more code</span>
</pre>

<p>If all the code in that method was covered you’d never know if the guard clause was ever triggered! With line coverage as just evaluating the condition marks it as covered.</p>

<p>In the HTML report the lines of code will be annotated like <code>branch_type: hit_count</code>:</p>
<ul><li>
<p><code>then: 2</code> - the then branch (of an <code>if</code>) was executed twice</p>
</li><li>
<p><code>else: 0</code> - the else branch (of an <code>if</code> or <code>case</code>) was never executed</p>
</li></ul>

<p>Not that even if you don’t declare an <code>else</code> branch it will still show up in the coverage reports meaning that the condition of the <code>if</code> was not hit or that no <code>when</code> of <code>case</code> was hit during the test runs.</p>

<p><strong>Is branch coverage strictly better?</strong> No. Branch coverage really only concerns itself with conditionals - meaning coverage of sequential code is of no interest to it. <a href="../../../../../../A.html"><code>A</code></a> file without conditional logic will have no branch coverage data and <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> will report 0 of 0 branches covered as 100% (as everything that can be covered was covered).</p>

<p>Hence, we recommend looking at both metrics together. Branch coverage might also be a good overall metric to look at - while you might be missing only 10% of your lines that might account for 50% of your branches for instance.</p>

<h2 id="label-Primary+Coverage">Primary Coverage<span><a href="#label-Primary+Coverage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>By default, the primary coverage type is <code>line</code>. To set the primary coverage to something else, use the following:</p>

<pre class="ruby"><span class="ruby-comment"># or in configure SimpleCov.primary_coverage :branch</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">enable_coverage</span> <span class="ruby-value">:branch</span>
  <span class="ruby-identifier">primary_coverage</span> <span class="ruby-value">:branch</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Primary coverage determines what will come in first all output, and the type of coverage to check if you don’t specify the type of coverage when customizing exit behavior (<code>SimpleCov.minimum_coverage 90</code>).</p>

<p>Note that coverage must first be enabled for non-default coverage types.</p>

<h2 id="label-Filters">Filters<span><a href="#label-Filters">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Filters can be used to remove selected files from your coverage data. By default, a filter is applied that removes all files OUTSIDE of your project’s root directory - otherwise you’d end up with billions of coverage reports for source files in the gems you are using.</p>

<p>You can define your own to remove things like configuration files, tests or whatever you don’t need in your coverage report.</p>

<h3 id="label-Defining+custom+filters">Defining custom filters<span><a href="#label-Defining+custom+filters">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can currently define a filter using either a <a href="../../../../../../String.html"><code>String</code></a> or Regexp (that will then be Regexp-matched against each source file’s path), a block or by passing in your own Filter class.</p>

<h4 id="label-String+filter"><a href="../../../../../../String.html"><code>String</code></a> filter<span><a href="#label-String+filter">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">add_filter</span> <span class="ruby-string">&quot;/test/&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This simple string filter will remove all files that match “/test/” in their path.</p>

<h4 id="label-Regex+filter">Regex filter<span><a href="#label-Regex+filter">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">add_filter</span> <span class="ruby-regexp">%r{^/test/}</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This simple regex filter will remove all files that start with /test/ in their path.</p>

<h4 id="label-Block+filter">Block filter<span><a href="#label-Block+filter">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">add_filter</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">source_file</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">source_file</span>.<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">count</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">5</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Block filters receive a <a href="../../../../../../SimpleCov/SourceFile.html"><code>SimpleCov::SourceFile</code></a> instance and expect your block to return either true (if the file is to be removed from the result) or false (if the result should be kept). Please check out the <a href="../../../../../../RDoc.html"><code>RDoc</code></a> for <a href="../../../../../../SimpleCov/SourceFile.html"><code>SimpleCov::SourceFile</code></a> to learn about the methods available to you. In the above example, the filter will remove all files that have less than 5 lines of code.</p>

<h4 id="label-Custom+filter+class">Custom filter class<span><a href="#label-Custom+filter+class">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">LineFilter</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Filter</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matches?</span>(<span class="ruby-identifier">source_file</span>)
    <span class="ruby-identifier">source_file</span>.<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">count</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">filter_argument</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">add_filter</span> <span class="ruby-constant">LineFilter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">5</span>)
</pre>

<p>Defining your own filters is pretty easy: Just inherit from <a href="../../../../../../SimpleCov/Filter.html"><code>SimpleCov::Filter</code></a> and define a method ‘matches?(source_file)’. When running the filter, a true return value from this method will result in the removal of the given source_file. The filter_argument method is being set in the <a href="../../../../../../SimpleCov/Filter.html"><code>SimpleCov::Filter</code></a> initialize method and thus is set to 5 in this example.</p>

<h4 id="label-Array+filter"><a href="../../../../../../Array.html"><code>Array</code></a> filter<span><a href="#label-Array+filter">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">proc</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">source_file</span><span class="ruby-operator">|</span> <span class="ruby-keyword">false</span> }
  <span class="ruby-identifier">add_filter</span> [<span class="ruby-string">&quot;string&quot;</span>, <span class="ruby-regexp">/regex/</span>, <span class="ruby-identifier">proc</span>, <span class="ruby-constant">LineFilter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">5</span>)]
<span class="ruby-keyword">end</span>
</pre>

<p>You can pass in an array containing any of the other filter types.</p>

<h4 id="label-Ignoring-2Fskipping+code">Ignoring/skipping code<span><a href="#label-Ignoring-2Fskipping+code">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>You can exclude code from the coverage report by wrapping it in <code># :nocov:</code>.</p>

<pre class="ruby"><span class="ruby-comment"># :nocov:</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_this_method</span>
  <span class="ruby-identifier">never_reached</span>
<span class="ruby-keyword">end</span>
<span class="ruby-comment"># :nocov:</span>
</pre>

<p>The name of the token can be changed to your liking. <a href="https://github.com/simplecov-ruby/simplecov/blob/main/features/config_nocov_token.feature">Learn more about the nocov feature.</a></p>

<p><strong>Note:</strong> You shouldn’t have to use the nocov token to skip private methods that are being included in your coverage. If you appropriately test the public interface of your classes and objects you should automatically get full coverage of your private methods.</p>

<h2 id="label-Default+root+filter+and+coverage+for+things+outside+of+it">Default root filter and coverage for things outside of it<span><a href="#label-Default+root+filter+and+coverage+for+things+outside+of+it">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>By default, <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> filters everything outside of the <code>SimpleCov.root</code> directory. However, sometimes you may want to include coverage reports for things you include as a gem, for example a Rails Engine.</p>

<p>Here’s an example by <a href="https://github.com/lsaffie">@lsaffie</a> from <a href="https://github.com/simplecov-ruby/simplecov/issues/221">#221</a> that shows how you can achieve just that:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-value">:rails</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">filters</span>.<span class="ruby-identifier">clear</span> <span class="ruby-comment"># This will remove the :root_filter and :bundler_filter that come via simplecov&#39;s defaults</span>
  <span class="ruby-identifier">add_filter</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">src</span><span class="ruby-operator">|</span>
    <span class="ruby-operator">!</span>(<span class="ruby-identifier">src</span>.<span class="ruby-identifier">filename</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/^#{SimpleCov.root}/</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">src</span>.<span class="ruby-identifier">filename</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/my_engine/</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Groups">Groups<span><a href="#label-Groups">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can separate your source files into groups. For example, in a Rails app, you’ll want to have separate listings for Models, Controllers, Helpers, and Libs. Group definition works similarly to Filters (and also accepts custom filter classes), but source files end up in a group when the filter passes (returns true), as opposed to filtering results, which exclude files from results when the filter results in a true value.</p>

<p>Add your groups with:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">add_group</span> <span class="ruby-string">&quot;Models&quot;</span>, <span class="ruby-string">&quot;app/models&quot;</span>
  <span class="ruby-identifier">add_group</span> <span class="ruby-string">&quot;Controllers&quot;</span>, <span class="ruby-string">&quot;app/controllers&quot;</span>
  <span class="ruby-identifier">add_group</span> <span class="ruby-string">&quot;Long files&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">src_file</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">src_file</span>.<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">count</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">100</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">add_group</span> <span class="ruby-string">&quot;Multiple Files&quot;</span>, [<span class="ruby-string">&quot;app/models&quot;</span>, <span class="ruby-string">&quot;app/controllers&quot;</span>] <span class="ruby-comment"># You can also pass in an array</span>
  <span class="ruby-identifier">add_group</span> <span class="ruby-string">&quot;Short files&quot;</span>, <span class="ruby-constant">LineFilter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">5</span>) <span class="ruby-comment"># Using the LineFilter class defined in Filters section above</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Merging+results">Merging results<span><a href="#label-Merging+results">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You normally want to have your coverage analyzed across ALL of your test suites, right?</p>

<p>Simplecov automatically caches coverage results in your (coverage_path)/.resultset.json, and will merge or override those with subsequent runs, depending on whether simplecov considers those subsequent runs as different test suites or as the same test suite as the cached results. To make this distinction, simplecov has the concept of “test suite names”.</p>

<h3 id="label-Test+suite+names">Test suite names<span><a href="#label-Test+suite+names">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> tries to guess the name of the currently running test suite based upon the shell command the tests are running on. This should work fine for Unit Tests, RSpec, and Cucumber. If it fails, it will use the shell command that invoked the test suite as a command name.</p>

<p>If you have some non-standard setup and still want nicely labeled test suites, you have to give Simplecov a cue as to what the name of the currently running test suite is. You can do so by specifying <code>SimpleCov.command_name</code> in one test file that is part of your specific suite.</p>

<p>To customize the suite names on a Rails app (yeah, sorry for being Rails-biased, but everyone knows what the structure of those projects is. You can apply this accordingly to the RSpecs in your Outlook-WebDAV-Calendar-Sync gem), you could do something like this:</p>

<pre class="ruby"><span class="ruby-comment"># test/unit/some_test.rb</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">command_name</span> <span class="ruby-string">&#39;test:units&#39;</span>

<span class="ruby-comment"># test/functionals/some_controller_test.rb</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">command_name</span> <span class="ruby-string">&quot;test:functionals&quot;</span>

<span class="ruby-comment"># test/integration/some_integration_test.rb</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">command_name</span> <span class="ruby-string">&quot;test:integration&quot;</span>

<span class="ruby-comment"># features/support/env.rb</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">command_name</span> <span class="ruby-string">&quot;features&quot;</span>
</pre>

<p>Note that this only has to be invoked ONCE PER TEST SUITE, so even if you have 200 unit test files, specifying it in <code>some_test.rb</code> is enough.</p>

<p>Last but not least <strong>if multiple suites resolve to the same <code>command_name</code></strong> be aware that the coverage results <strong>will clobber each other instead of being merged</strong>. <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> is smart enough to detect unique names for the most common setups, but if you have more than one test suite that doesn’t follow a common pattern then you will want to manually ensure that each suite gets a unique <code>command_name</code>.</p>

<p>If you are running tests in parallel each process has the potential to clobber results from the other test processes. If you are relying on the default <code>command_name</code> then <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> will attempt to detect and avoid parallel test suite <code>command_name</code> collisions based on the presence of <code>ENV[&#39;PARALLEL_TEST_GROUPS&#39;]</code> and <code>ENV[&#39;TEST_ENV_NUMBER&#39;]</code>. If your parallel test runner does not set one or both of these then <em>you must</em> set a <code>command_name</code> and ensure that it is unique per process (eg. <code>command_name &quot;Unit Tests PID #{$$}&quot;</code>).</p>

<p>If you are using parallel_tests, you must incorporate <code>TEST_ENV_NUMBER</code> into the command name yourself, in order for <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> to merge the results correctly. For example:</p>

<pre class="ruby"><span class="ruby-comment"># spec/spec_helper.rb</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">command_name</span> <span class="ruby-string">&quot;features&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-constant">ENV</span>[<span class="ruby-string">&#39;TEST_ENV_NUMBER&#39;</span>] <span class="ruby-operator">||</span> <span class="ruby-string">&#39;&#39;</span>)
</pre>

<p><a href="https://github.com/simplecov-ruby/simplecov-html">simplecov-html</a> prints the used test suites in the footer of the generated coverage report.</p>

<h3 id="label-Merging+test+runs+under+the+same+execution+environment">Merging test runs under the same execution environment<span><a href="#label-Merging+test+runs+under+the+same+execution+environment">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Test results are automatically merged with previous runs in the same execution environment when generating the result, so when coverage is set up properly for Cucumber and your unit / functional / integration tests, all of those test suites will be taken into account when building the coverage report.</p>

<h4 id="label-Timeout+for+merge">Timeout for merge<span><a href="#label-Timeout+for+merge">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Of course, your cached coverage data is likely to become invalid at some point. Thus, when automatically merging subsequent test runs, result sets that are older than <code>SimpleCov.merge_timeout</code> will not be used any more. By default, the timeout is 600 seconds (10 minutes), and you can raise (or lower) it by specifying <code>SimpleCov.merge_timeout 3600</code> (1 hour), or, inside a configure/start block, with just <code>merge_timeout 3600</code>.</p>

<p>You can deactivate this automatic merging altogether with <code>SimpleCov.use_merging false</code>.</p>

<h3 id="label-Merging+test+runs+under+different+execution+environments">Merging test runs under different execution environments<span><a href="#label-Merging+test+runs+under+different+execution+environments">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>If your tests are done in parallel across multiple build machines, you can fetch them all and merge them into a single result set using the <code>SimpleCov.collate</code> method. This can be added to a <a href="../../../../../../Rakefile.html">Rakefile</a> or script file, having downloaded a set of <code>.resultset.json</code> files from each parallel test run.</p>

<pre class="ruby"><span class="ruby-comment"># lib/tasks/coverage_report.rake</span>
<span class="ruby-identifier">namespace</span> <span class="ruby-value">:coverage</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">desc</span> <span class="ruby-string">&quot;Collates all result sets generated by the different test runners&quot;</span>
  <span class="ruby-identifier">task</span> <span class="ruby-value">:report</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov&#39;</span>

    <span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">collate</span> <span class="ruby-constant">Dir</span>[<span class="ruby-string">&quot;simplecov-resultset-*/.resultset.json&quot;</span>]
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p><code>SimpleCov.collate</code> also takes an optional simplecov profile and an optional block for configuration, just the same as <code>SimpleCov.start</code> or <code>SimpleCov.configure</code>. This means you can configure a separate formatter for the collated output. For instance, you can make the formatter in <code>SimpleCov.start</code> the <code>SimpleCov::Formatter::SimpleFormatter</code>, and only use more complex formatters in the final <code>SimpleCov.collate</code> run.</p>

<pre class="ruby"><span class="ruby-comment"># spec/spec_helper.rb</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov&#39;</span>

<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-string">&#39;rails&#39;</span> <span class="ruby-keyword">do</span>
  <span class="ruby-comment"># Disambiguates individual test runs</span>
  <span class="ruby-identifier">command_name</span> <span class="ruby-node">&quot;Job #{ENV[&quot;TEST_ENV_NUMBER&quot;]}&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">ENV</span>[<span class="ruby-string">&quot;TEST_ENV_NUMBER&quot;</span>]

  <span class="ruby-keyword">if</span> <span class="ruby-constant">ENV</span>[<span class="ruby-string">&#39;CI&#39;</span>]
    <span class="ruby-identifier">formatter</span> <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleFormatter</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">formatter</span> <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">MultiFormatter</span>.<span class="ruby-identifier">new</span>([
      <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleFormatter</span>,
      <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">HTMLFormatter</span>
    ])
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">track_files</span> <span class="ruby-string">&quot;**/*.rb&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<pre class="ruby"><span class="ruby-comment"># lib/tasks/coverage_report.rake</span>
<span class="ruby-identifier">namespace</span> <span class="ruby-value">:coverage</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">task</span> <span class="ruby-value">:report</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov&#39;</span>

    <span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">collate</span> <span class="ruby-constant">Dir</span>[<span class="ruby-string">&quot;simplecov-resultset-*/.resultset.json&quot;</span>], <span class="ruby-string">&#39;rails&#39;</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">formatter</span> <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">MultiFormatter</span>.<span class="ruby-identifier">new</span>([
        <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleFormatter</span>,
        <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">HTMLFormatter</span>
      ])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Running+simplecov+against+subprocesses">Running simplecov against subprocesses<span><a href="#label-Running+simplecov+against+subprocesses">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><code>SimpleCov.enable_for_subprocesses</code> will allow <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> to observe subprocesses starting using <code>Process.fork</code>. This modifies ruby’s core <a href="../../../../../../Process.html#method-c-fork"><code>Process.fork</code></a> method so that <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> can see into it, appending <code>&quot; (subprocess #{pid})&quot;</code> to the <code>SimpleCov.command_name</code>, with results that can be merged together using SimpleCov’s merging feature.</p>

<p>To configure this, use <code>.at_fork</code>.</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">enable_for_subprocesses</span> <span class="ruby-keyword">true</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">at_fork</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">pid</span><span class="ruby-operator">|</span>
  <span class="ruby-comment"># This needs a unique name so it won&#39;t be ovewritten</span>
  <span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">command_name</span> <span class="ruby-node">&quot;#{SimpleCov.command_name} (subprocess: #{pid})&quot;</span>
  <span class="ruby-comment"># be quiet, the parent process will be in charge of output and checking coverage totals</span>
  <span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">print_error_status</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">formatter</span> <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleFormatter</span>
  <span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">minimum_coverage</span> <span class="ruby-value">0</span>
  <span class="ruby-comment"># start</span>
  <span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span>
<span class="ruby-keyword">end</span>
</pre>

<p>NOTE: <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> must have already been started before <code>Process.fork</code> was called.</p>

<h3 id="label-Running+simplecov+against+spawned+subprocesses">Running simplecov against spawned subprocesses<span><a href="#label-Running+simplecov+against+spawned+subprocesses">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Perhaps you’re testing a ruby script with <code>PTY.spawn</code> or <code>Open3.popen</code>, or <code>Process.spawn</code> or etc. <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> can cover this too.</p>

<p>Add a .simplecov_spawn.rb file to your project root</p>

<pre class="ruby"><span class="ruby-comment"># .simplecov_spawn.rb</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov&#39;</span> <span class="ruby-comment"># this will also pick up whatever config is in .simplecov</span>
                    <span class="ruby-comment"># so ensure it just contains configuration, and doesn&#39;t call SimpleCov.start.</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">command_name</span> <span class="ruby-string">&#39;spawn&#39;</span> <span class="ruby-comment"># As this is not for a test runner directly, script doesn&#39;t have a pre-defined base command_name</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">at_fork</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">Process</span>.<span class="ruby-identifier">pid</span>) <span class="ruby-comment"># Use the per-process setup described previously</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-comment"># only now can we start.</span>
</pre>

<p>Then, instead of calling your script directly, like:</p>

<pre class="ruby"><span class="ruby-constant">PTY</span>.<span class="ruby-identifier">spawn</span>(<span class="ruby-string">&#39;my_script.rb&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-comment"># ...</span>
</pre>

<p>Use bin/ruby to require the new .simplecov_spawn file, then your script</p>

<pre class="ruby"><span class="ruby-constant">PTY</span>.<span class="ruby-identifier">spawn</span>(<span class="ruby-string">&#39;ruby -r./.simplecov_spawn my_script.rb&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-comment"># ...</span>
</pre>

<h2 id="label-Running+coverage+only+on+demand">Running coverage only on demand<span><a href="#label-Running+coverage+only+on+demand">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The Ruby STDLIB Coverage library that <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> builds upon is <em>very</em> fast (on a ~10 min Rails test suite, the speed drop was only a couple seconds for me), and therefore it’s SimpleCov’s policy to just generate coverage every time you run your tests because it doesn’t do your test speed any harm and you’re always equipped with the latest and greatest coverage results.</p>

<p>Because of this, <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> has no explicit built-in mechanism to run coverage only on demand.</p>

<p>However, you can still accomplish this very easily by introducing an ENV variable conditional into your <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> setup block, like this:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">ENV</span>[<span class="ruby-string">&quot;COVERAGE&quot;</span>]
</pre>

<p>Then, <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> will only run if you execute your tests like this:</p>

<pre>COVERAGE=true rake test</pre>

<h2 id="label-Errors+and+exit+statuses">Errors and exit statuses<span><a href="#label-Errors+and+exit+statuses">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To aid in debugging issues, if an error is raised, <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> will print a message to <code>STDERR</code> with the exit status of the error, like:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span> <span class="ruby-identifier">failed</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">exit</span> <span class="ruby-value">1</span>
</pre>

<p>This <code>STDERR</code> message can be disabled with:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">print_error_status</span> = <span class="ruby-keyword">false</span>
</pre>

<h2 id="label-Profiles">Profiles<span><a href="#label-Profiles">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>By default, SimpleCov’s only config assumption is that you only want coverage reports for files inside your project root. To save yourself from repetitive configuration, you can use predefined blocks of configuration, called ‘profiles’, or define your own.</p>

<p>You can then pass the name of the profile to be used as the first argument to <a href="../../../../../../SimpleCov.html#method-c-start"><code>SimpleCov.start</code></a>. For example, simplecov comes bundled with a ‘rails’ profile. It looks somewhat like this:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">profiles</span>.<span class="ruby-identifier">define</span> <span class="ruby-string">&#39;rails&#39;</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">add_filter</span> <span class="ruby-string">&#39;/test/&#39;</span>
  <span class="ruby-identifier">add_filter</span> <span class="ruby-string">&#39;/config/&#39;</span>

  <span class="ruby-identifier">add_group</span> <span class="ruby-string">&#39;Controllers&#39;</span>, <span class="ruby-string">&#39;app/controllers&#39;</span>
  <span class="ruby-identifier">add_group</span> <span class="ruby-string">&#39;Models&#39;</span>, <span class="ruby-string">&#39;app/models&#39;</span>
  <span class="ruby-identifier">add_group</span> <span class="ruby-string">&#39;Helpers&#39;</span>, <span class="ruby-string">&#39;app/helpers&#39;</span>
  <span class="ruby-identifier">add_group</span> <span class="ruby-string">&#39;Libraries&#39;</span>, <span class="ruby-string">&#39;lib&#39;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>As you can see, it’s just a SimpleCov.configure block. In your test_helper.rb, launch <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> with:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-string">&#39;rails&#39;</span>
</pre>

<p>or</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-string">&#39;rails&#39;</span> <span class="ruby-keyword">do</span>
  <span class="ruby-comment"># additional config here</span>
<span class="ruby-keyword">end</span>
</pre>

<h3 id="label-Custom+profiles">Custom profiles<span><a href="#label-Custom+profiles">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can load additional profiles with the <a href="../../../../../../SimpleCov.html#method-c-load_profile"><code>SimpleCov.load_profile</code></a>(‘xyz’) method. This allows you to build upon an existing profile and customize it so you can reuse it in unit tests and Cucumber features. For example:</p>

<pre class="ruby"><span class="ruby-comment"># lib/simplecov_custom_profile.rb</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov&#39;</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">profiles</span>.<span class="ruby-identifier">define</span> <span class="ruby-string">&#39;myprofile&#39;</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">load_profile</span> <span class="ruby-string">&#39;rails&#39;</span>
  <span class="ruby-identifier">add_filter</span> <span class="ruby-string">&#39;vendor&#39;</span> <span class="ruby-comment"># Don&#39;t include vendored stuff</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># features/support/env.rb</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov_custom_profile&#39;</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-string">&#39;myprofile&#39;</span>

<span class="ruby-comment"># test/test_helper.rb</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov_custom_profile&#39;</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-string">&#39;myprofile&#39;</span>
</pre>

<h2 id="label-Customizing+exit+behaviour">Customizing exit behaviour<span><a href="#label-Customizing+exit+behaviour">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can define what <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> should do when your test suite finishes by customizing the at_exit hook:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">at_exit</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">result</span>.<span class="ruby-identifier">format!</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Above is the default behaviour. Do whatever you like instead!</p>

<h3 id="label-Minimum+coverage">Minimum coverage<span><a href="#label-Minimum+coverage">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can define the minimum coverage percentage expected. <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> will return non-zero if unmet.</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">minimum_coverage</span> <span class="ruby-value">90</span>
<span class="ruby-comment"># same as above (the default is to check line coverage)</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">minimum_coverage</span> <span class="ruby-value">line:</span> <span class="ruby-value">90</span>
<span class="ruby-comment"># check for a minimum line coverage of 90% and minimum 80% branch coverage</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">minimum_coverage</span> <span class="ruby-value">line:</span> <span class="ruby-value">90</span>, <span class="ruby-value">branch:</span> <span class="ruby-value">80</span>
</pre>

<h3 id="label-Minimum+coverage+by+file">Minimum coverage by file<span><a href="#label-Minimum+coverage+by+file">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can define the minimum coverage by file percentage expected. <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> will return non-zero if unmet. This is useful to help ensure coverage is relatively consistent, rather than being skewed by particularly good or bad areas of the code.</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">minimum_coverage_by_file</span> <span class="ruby-value">80</span>
<span class="ruby-comment"># same as above (the default is to check line coverage by file)</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">minimum_coverage_by_file</span> <span class="ruby-value">line:</span> <span class="ruby-value">80</span>
<span class="ruby-comment"># check for a minimum line coverage by file of 90% and minimum 80% branch coverage</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">minimum_coverage_by_file</span> <span class="ruby-value">line:</span> <span class="ruby-value">90</span>, <span class="ruby-value">branch:</span> <span class="ruby-value">80</span>
</pre>

<h3 id="label-Maximum+coverage+drop">Maximum coverage drop<span><a href="#label-Maximum+coverage+drop">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can define the maximum coverage drop percentage at once. <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> will return non-zero if exceeded.</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">maximum_coverage_drop</span> <span class="ruby-value">5</span>
<span class="ruby-comment"># same as above (the default is to check line drop)</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">maximum_coverage_drop</span> <span class="ruby-value">line:</span> <span class="ruby-value">5</span>
<span class="ruby-comment"># check for a maximum line drop of 5% and maximum 10% branch drop</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">maximum_coverage_drop</span> <span class="ruby-value">line:</span> <span class="ruby-value">5</span>, <span class="ruby-value">branch:</span> <span class="ruby-value">10</span>
</pre>

<h3 id="label-Refuse+dropping+coverage">Refuse dropping coverage<span><a href="#label-Refuse+dropping+coverage">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can also entirely refuse dropping coverage between test runs:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">refuse_coverage_drop</span>
<span class="ruby-comment"># same as above (the default is to only refuse line drop)</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">refuse_coverage_drop</span> <span class="ruby-value">:line</span>
<span class="ruby-comment"># refuse drop for line and branch</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">refuse_coverage_drop</span> <span class="ruby-value">:line</span>, <span class="ruby-value">:branch</span>
</pre>

<h2 id="label-Using+your+own+formatter">Using your own formatter<span><a href="#label-Using+your+own+formatter">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can use your own formatter with:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">formatter</span> = <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">HTMLFormatter</span>
</pre>

<p>When calling <a href="../../../../../../SimpleCov.html#method-c-result"><code>SimpleCov.result</code></a>.format!, it will be invoked with SimpleCov::Formatter::YourFormatter.new.format(result), "result" being an instance of <a href="../../../../../../SimpleCov/Result.html"><code>SimpleCov::Result</code></a>. Do whatever your wish with that!</p>

<h2 id="label-Using+multiple+formatters">Using multiple formatters<span><a href="#label-Using+multiple+formatters">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>As of <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> 0.9, you can specify multiple result formats:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">formatters</span> = <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">MultiFormatter</span>.<span class="ruby-identifier">new</span>([
  <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">HTMLFormatter</span>,
  <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">CSVFormatter</span>,
])
</pre>

<h2 id="label-JSON+formatter">JSON formatter<span><a href="#label-JSON+formatter">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> is packaged with a separate gem called <a href="https://github.com/codeclimate-community/simplecov_json_formatter">simplecov_json_formatter</a> that provides you with a JSON formatter, this formatter could be useful for different use cases, such as for CI consumption or for reporting to external services.</p>

<p>In order to use it you will need to manually load the installed gem like so:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;simplecov_json_formatter&quot;</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">formatter</span> = <span class="ruby-constant">SimpleCov</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">JSONFormatter</span>
</pre>

<blockquote>
<p><em>Note:</em> In case you plan to report your coverage results to CodeClimate services, know that <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> will automatically use the  JSON formatter along with the HTML formatter when the <code>CC_TEST_REPORTER_ID</code> variable is present in the environment.</p>
</blockquote>

<h2 id="label-Available+formatters-2C+editor+integrations+and+hosted+services">Available formatters, editor integrations and hosted services<span><a href="#label-Available+formatters-2C+editor+integrations+and+hosted+services">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><a href="doc/alternate-formatters_md.html">Open Source formatter and integration plugins for SimpleCov</a></p>
</li><li>
<p><a href="doc/editor-integration_md.html">Editor Integration</a></p>
</li><li>
<p><a href="doc/commercial-services_md.html">Hosted (commercial) services</a></p>
</li></ul>

<h2 id="label-Ruby+version+compatibility">Ruby version compatibility<span><a href="#label-Ruby+version+compatibility">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> is built in <a href="https://github.com/simplecov-ruby/simplecov/actions?query=workflow%3Astable">Continuous Integration</a> on Ruby 2.5+ as well as JRuby 9.2+.</p>

<p>Note for JRuby =&gt; You need to pass JRUBY_OPTS=“–debug” or create .jrubyrc and add debug.fullTrace=true</p>

<h2 id="label-Want+to+find+dead+code+in+production-3F">Want to find dead code in production?<span><a href="#label-Want+to+find+dead+code+in+production-3F">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Try <a href="https://github.com/danmayer/coverband">Coverband</a>.</p>

<h2 id="label-Want+to+use+Spring+with+SimpleCov-3F">Want to use Spring with <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a>?<span><a href="#label-Want+to+use+Spring+with+SimpleCov-3F">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If you’re using <a href="https://github.com/rails/spring">Spring</a> to speed up test suite runs and want to run <a href="../../../../../../SimpleCov.html"><code>SimpleCov</code></a> along with them, you’ll find that it often misreports coverage with the default config due to some sort of eager loading issue. Don’t despair!</p>

<p>One solution is to <a href="https://github.com/simplecov-ruby/simplecov/issues/381#issuecomment-347651728">explicitly call eager load</a> in your <code>test_helper.rb</code> / <code>spec_helper.rb</code> after calling <code>SimpleCov.start</code>.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;simplecov&#39;</span>
<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span> <span class="ruby-string">&#39;rails&#39;</span>
<span class="ruby-constant">Rails</span>.<span class="ruby-identifier">application</span>.<span class="ruby-identifier">eager_load!</span>
</pre>

<p>Alternatively, you could disable Spring while running SimpleCov:</p>

<pre>DISABLE_SPRING=1 rake test</pre>

<p>Or you could remove <code>gem &#39;spring&#39;</code> from your <code>Gemfile</code>.</p>

<h2 id="label-Troubleshooting">Troubleshooting<span><a href="#label-Troubleshooting">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <strong>most common problem is that simplecov isn’t required and started before everything else</strong>. In order to track coverage for your whole application <strong>simplecov needs to be the first one</strong> so that it (and the underlying coverage library) can subsequently track loaded files and their usage.</p>

<p>If you are missing coverage for some code a simple trick is to put a puts statement in there and right after <code>SimpleCov.start</code> so you can see if the file really was loaded after simplecov was started.</p>

<pre class="ruby"><span class="ruby-comment"># my_code.rb</span>
<span class="ruby-keyword">class</span> <span class="ruby-constant">MyCode</span>

  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;MyCode is being loaded!&quot;</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">my_method</span>
    <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># spec_helper.rb/rails_helper.rb/test_helper.rb/.simplecov whatever</span>

<span class="ruby-constant">SimpleCov</span>.<span class="ruby-identifier">start</span>
<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;SimpleCov started successfully!&quot;</span>
</pre>

<p>Now when you run your test suite and you see:</p>

<pre class="ruby"><span class="ruby-constant">SimpleCov</span> <span class="ruby-identifier">started</span> <span class="ruby-identifier">successfully!</span>
<span class="ruby-constant">MyCode</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">being</span> <span class="ruby-identifier">loaded!</span>
</pre>

<p>then it’s good otherwise you likely have a problem :)</p>

<h2 id="label-Code+of+Conduct">Code of Conduct<span><a href="#label-Code+of+Conduct">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Everyone participating in this project’s development, issue trackers and other channels is expected to follow our <a href="./CODE_OF_CONDUCT_md.html">Code of Conduct</a></p>

<h2 id="label-Contributing">Contributing<span><a href="#label-Contributing">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>See the <a href="https://github.com/simplecov-ruby/simplecov/blob/main/CONTRIBUTING.md">contributing guide</a>.</p>

<h2 id="label-Kudos">Kudos<span><a href="#label-Kudos">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Thanks to Aaron Patterson for the original idea for this!</p>

<h2 id="label-Copyright">Copyright<span><a href="#label-Copyright">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Copyright © 2010-2017 Christoph Olszowka. See MIT-LICENSE for details.</p>

</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

