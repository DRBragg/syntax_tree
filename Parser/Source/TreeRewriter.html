<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Parser::Source::TreeRewriter - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link"><a href="../../Object.html">Object</a>
</div>

    
    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-new">::new</a>
    <li ><a href="#method-i-as_nested_actions">#as_nested_actions</a>
    <li ><a href="#method-i-as_replacements">#as_replacements</a>
    <li ><a href="#method-i-empty-3F">#empty?</a>
    <li ><a href="#method-i-import-21">#import!</a>
    <li ><a href="#method-i-in_transaction-3F">#in_transaction?</a>
    <li ><a href="#method-i-insert_after">#insert_after</a>
    <li ><a href="#method-i-insert_before">#insert_before</a>
    <li ><a href="#method-i-merge">#merge</a>
    <li ><a href="#method-i-merge-21">#merge!</a>
    <li ><a href="#method-i-process">#process</a>
    <li ><a href="#method-i-remove">#remove</a>
    <li ><a href="#method-i-replace">#replace</a>
    <li ><a href="#method-i-transaction">#transaction</a>
    <li ><a href="#method-i-wrap">#wrap</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Parser::Source::TreeRewriter">
  <h1 id="class-Parser::Source::TreeRewriter" class="class">
    class Parser::Source::TreeRewriter
  </h1>

  <section class="description">
    
<p>{TreeRewriter} performs the heavy lifting in the source rewriting process. It schedules code updates to be performed in the correct order.</p>

<p>For simple cases, the resulting source will be obvious.</p>

<p>Examples for more complex cases follow. Assume these examples are acting on the source ‘’puts(:hello, :world)‘. The methods <a href="TreeRewriter.html#method-i-wrap"><code>wrap</code></a>, <a href="TreeRewriter.html#method-i-remove"><code>remove</code></a>, etc. receive a <a href="Range.html"><code>Range</code></a> as first argument; for clarity, examples below use english sentences and a string of raw code instead.</p>

<p>## Overlapping ranges:</p>

<p>Any two rewriting actions on overlapping ranges will fail and raise a ‘ClobberingError`, unless they are both deletions (covered next).</p>
<ul><li>
<p>wrap ‘:hello, ’ with ‘(’ and ‘)’</p>
</li><li>
<p>wrap ‘, :world’ with ‘(’ and ‘)’</p>
</li></ul>

<pre>=&gt; CloberringError</pre>

<p>## Overlapping deletions:</p>
<ul><li>
<p>remove ‘:hello, ’</p>
</li><li>
<p>remove ‘, :world’</p>
</li></ul>

<p>The overlapping ranges are merged and ‘’:hello, :world’‘ will be removed. This policy can be changed. `:crossing_deletions` defaults to `:accept` but can be set to `:warn` or `:raise`.</p>

<p>## Multiple actions at the same end points:</p>

<p>Results will always be independent on the order they were given. Exception: rewriting actions done on exactly the same range (covered next).</p>

<p>Example:</p>
<ul><li>
<p>replace ‘, ’ by ‘ =&gt; ’</p>
</li><li>
<p>wrap ‘:hello, :world’ with ‘{’ and ‘}’</p>
</li><li>
<p>replace ‘:world’ with ‘:everybody’</p>
</li><li>
<p>wrap ‘:world’ with ‘[’, ‘]’</p>
</li></ul>

<p>The resulting string will be ‘’puts({:hello =&gt; [:everybody]})‘` and this result is independent on the order the instructions were given in.</p>

<p>Note that if the two “replace” were given as a single replacement of ‘, :world’ for ‘ =&gt; :everybody’, the result would be a ‘ClobberingError` because of the wrap in square brackets.</p>

<p>## Multiple wraps on same range:</p>
<ul><li>
<p>wrap ‘:hello’ with ‘(’ and ‘)’</p>
</li><li>
<p>wrap ‘:hello’ with ‘[’ and ‘]’</p>
</li></ul>

<p>The wraps are combined in order given and results would be ‘’<a href="(:hello)">puts(</a>, :world)‘`.</p>

<p>## Multiple replacements on same range:</p>
<ul><li>
<p>replace ‘:hello’ by ‘:hi’, then</p>
</li><li>
<p>replace ‘:hello’ by ‘:hey’</p>
</li></ul>

<p>The replacements are made in the order given, so the latter replacement supersedes the former and ‘:hello’ will be replaced by ‘:hey’.</p>

<p>This policy can be changed. ‘:different_replacements` defaults to `:accept` but can be set to `:warn` or `:raise`.</p>

<p>## Swallowed insertions: wrap ‘world’ by ‘__’, ‘__’ replace ‘:hello, :world’ with ‘:hi’</p>

<p><a href="../../A.html"><code>A</code></a> containing replacement will swallow the contained rewriting actions and ‘’:hello, :world’‘ will be replaced by `’:hi’‘.</p>

<p>This policy can be changed for swallowed insertions. ‘:swallowed_insertions` defaults to `:accept` but can be set to `:warn` or `:raise`</p>

<p>## Implementation The updates are organized in a tree, according to the ranges they act on (where children are strictly contained by their parent), hence the name.</p>

<p>@!attribute [r] <a href="TreeRewriter.html#attribute-i-source_buffer"><code>source_buffer</code></a></p>

<pre class="ruby"><span class="ruby-ivar">@return</span> [<span class="ruby-constant">Source</span><span class="ruby-operator">::</span><span class="ruby-constant">Buffer</span>]
</pre>

<p>@!attribute [r] diagnostics</p>

<pre class="ruby"><span class="ruby-ivar">@return</span> [<span class="ruby-constant">Diagnostic</span><span class="ruby-operator">::</span><span class="ruby-constant">Engine</span>]
</pre>

<p>@api public</p>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">



    <section class="attribute-method-details" class="method-section">
      <header>
        <h3>Attributes</h3>
      </header>

      <div id="attribute-i-diagnostics" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">diagnostics</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        </div>
      </div>
      <div id="attribute-i-source_buffer" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">source_buffer</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        </div>
      </div>
    </section>


     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-new" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(source_buffer, crossing_deletions: :accept, different_replacements: :accept, swallowed_insertions: :accept)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>@param [Source::Buffer] <a href="TreeRewriter.html#attribute-i-source_buffer"><code>source_buffer</code></a></p>

          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">source_buffer</span>,
               <span class="ruby-value">crossing_deletions:</span> <span class="ruby-value">:accept</span>,
               <span class="ruby-value">different_replacements:</span> <span class="ruby-value">:accept</span>,
               <span class="ruby-value">swallowed_insertions:</span> <span class="ruby-value">:accept</span>)
  <span class="ruby-ivar">@diagnostics</span> = <span class="ruby-constant">Diagnostic</span><span class="ruby-operator">::</span><span class="ruby-constant">Engine</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-ivar">@diagnostics</span>.<span class="ruby-identifier">consumer</span> = <span class="ruby-operator">-&gt;</span> <span class="ruby-identifier">diag</span> { <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-identifier">diag</span>.<span class="ruby-identifier">render</span> }

  <span class="ruby-ivar">@source_buffer</span> = <span class="ruby-identifier">source_buffer</span>
  <span class="ruby-ivar">@in_transaction</span> = <span class="ruby-keyword">false</span>

  <span class="ruby-ivar">@policy</span> = {<span class="ruby-value">crossing_deletions:</span> <span class="ruby-identifier">crossing_deletions</span>,
             <span class="ruby-value">different_replacements:</span> <span class="ruby-identifier">different_replacements</span>,
             <span class="ruby-value">swallowed_insertions:</span> <span class="ruby-identifier">swallowed_insertions</span>}.<span class="ruby-identifier">freeze</span>
  <span class="ruby-identifier">check_policy_validity</span>

  <span class="ruby-ivar">@enforcer</span> = <span class="ruby-identifier">method</span>(<span class="ruby-value">:enforce_policy</span>)
  <span class="ruby-comment"># We need a range that would be jugded as containing all other ranges,</span>
  <span class="ruby-comment"># including 0...0 and size...size:</span>
  <span class="ruby-identifier">all_encompassing_range</span> = <span class="ruby-ivar">@source_buffer</span>.<span class="ruby-identifier">source_range</span>.<span class="ruby-identifier">adjust</span>(<span class="ruby-value">begin_pos:</span> <span class="ruby-value">-1</span>, <span class="ruby-value">end_pos:</span> <span class="ruby-value">+1</span>)
  <span class="ruby-ivar">@action_root</span> = <span class="ruby-constant">TreeRewriter</span><span class="ruby-operator">::</span><span class="ruby-constant">Action</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">all_encompassing_range</span>, <span class="ruby-ivar">@enforcer</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-as_nested_actions" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">as_nested_actions</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a representation of the rewriter as nested insertions (:wrap) and replacements.</p>

<pre>rewriter.as_actions # =&gt;[ [:wrap, 1...10, &#39;(&#39;, &#39;)&#39;],
                          [:wrap, 2...6, &#39;&#39;, &#39;!&#39;],  # aka &quot;insert_after&quot;
                          [:replace, 2...4, &#39;foo&#39;],
                          [:replace, 5...6, &#39;&#39;],  # aka &quot;removal&quot;
                        ],</pre>

<p>Contrary to ‘as_replacements`, this representation is sufficient to recreate exactly the rewriter.</p>

<p>@return [Array&lt;(Symbol, <a href="Range.html"><code>Range</code></a>, String{, String})&gt;]</p>

          <div class="method-source-code" id="as_nested_actions-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 299</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">as_nested_actions</span>
  <span class="ruby-ivar">@action_root</span>.<span class="ruby-identifier">nested_actions</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-as_replacements" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">as_replacements</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a representation of the rewriter as an ordered list of replacements.</p>

<pre>rewriter.as_replacements # =&gt; [ [1...1, &#39;(&#39;],
                                [2...4, &#39;foo&#39;],
                                [5...6, &#39;&#39;],
                                [6...6, &#39;!&#39;],
                                [10...10, &#39;)&#39;],
                              ]</pre>

<p>This representation is sufficient to recreate the result of ‘process` but it is not sufficient to recreate completely the rewriter for further merging/actions. See `as_nested_actions`</p>

<p>@return [Array&lt;Range, String&gt;] an ordered list of pairs of range &amp; replacement</p>

          <div class="method-source-code" id="as_replacements-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 281</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">as_replacements</span>
  <span class="ruby-ivar">@action_root</span>.<span class="ruby-identifier">ordered_replacements</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-empty-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">empty?</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true iff no (non trivial) update has been recorded</p>

<p>@return [Boolean]</p>

          <div class="method-source-code" id="empty-3F-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>
  <span class="ruby-ivar">@action_root</span>.<span class="ruby-identifier">empty?</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-import-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">import!</span><span
            class="method-args">(foreign_rewriter, offset: 0)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>For special cases where one needs to merge a rewriter attached to a different <a href="TreeRewriter.html#attribute-i-source_buffer"><code>source_buffer</code></a> or that needs to be offset. Policies of the receiver are used.</p>

<p>@param [TreeRewriter] rewriter from different <a href="TreeRewriter.html#attribute-i-source_buffer"><code>source_buffer</code></a> @param [Integer] offset @return [Rewriter] self @raise [IndexError] if action ranges (once offset) don’t fit the current buffer</p>

          <div class="method-source-code" id="import-21-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">import!</span>(<span class="ruby-identifier">foreign_rewriter</span>, <span class="ruby-value">offset:</span> <span class="ruby-value">0</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">foreign_rewriter</span>.<span class="ruby-identifier">empty?</span>

  <span class="ruby-identifier">contracted</span> = <span class="ruby-identifier">foreign_rewriter</span>.<span class="ruby-identifier">action_root</span>.<span class="ruby-identifier">contract</span>
  <span class="ruby-identifier">merge_effective_range</span> = <span class="ruby-operator">::</span><span class="ruby-constant">Parser</span><span class="ruby-operator">::</span><span class="ruby-constant">Source</span><span class="ruby-operator">::</span><span class="ruby-constant">Range</span>.<span class="ruby-identifier">new</span>(
    <span class="ruby-ivar">@source_buffer</span>,
    <span class="ruby-identifier">contracted</span>.<span class="ruby-identifier">range</span>.<span class="ruby-identifier">begin_pos</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">offset</span>,
    <span class="ruby-identifier">contracted</span>.<span class="ruby-identifier">range</span>.<span class="ruby-identifier">end_pos</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">offset</span>,
  )
  <span class="ruby-identifier">check_range_validity</span>(<span class="ruby-identifier">merge_effective_range</span>)

  <span class="ruby-identifier">merge_with</span> = <span class="ruby-identifier">contracted</span>.<span class="ruby-identifier">moved</span>(<span class="ruby-ivar">@source_buffer</span>, <span class="ruby-identifier">offset</span>)

  <span class="ruby-ivar">@action_root</span> = <span class="ruby-ivar">@action_root</span>.<span class="ruby-identifier">combine</span>(<span class="ruby-identifier">merge_with</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-in_transaction-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">in_transaction?</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          

          <div class="method-source-code" id="in_transaction-3F-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 329</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_transaction?</span>
  <span class="ruby-ivar">@in_transaction</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-insert_after" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">insert_after</span><span
            class="method-args">(range, content)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Shortcut for ‘wrap(range, nil, content)`</p>

<p>@param [Range] range @param [String] content @return [Rewriter] self @raise [ClobberingError] when clobbering is detected</p>

          <div class="method-source-code" id="insert_after-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert_after</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">content</span>)
  <span class="ruby-identifier">wrap</span>(<span class="ruby-identifier">range</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">content</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-insert_before" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">insert_before</span><span
            class="method-args">(range, content)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Shortcut for ‘wrap(range, content, nil)`</p>

<p>@param [Range] range @param [String] content @return [Rewriter] self @raise [ClobberingError] when clobbering is detected</p>

          <div class="method-source-code" id="insert_before-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert_before</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">content</span>)
  <span class="ruby-identifier">wrap</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">content</span>, <span class="ruby-keyword">nil</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-merge" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">merge</span><span
            class="method-args">(with)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns a new rewriter that consists of the updates of the received and the given argument. Policies of the receiver are used.</p>

<p>@param [Rewriter] with @return [Rewriter] merge of receiver and argument @raise [ClobberingError] when clobbering is detected</p>

          <div class="method-source-code" id="merge-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge</span>(<span class="ruby-identifier">with</span>)
  <span class="ruby-identifier">dup</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">with</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-merge-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">merge!</span><span
            class="method-args">(with)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Merges the updates of argument with the receiver. Policies of the receiver are used. This action is atomic in that it won’t change the receiver unless it succeeds.</p>

<p>@param [Rewriter] with @return [Rewriter] self @raise [ClobberingError] when clobbering is detected</p>

          <div class="method-source-code" id="merge-21-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge!</span>(<span class="ruby-identifier">with</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;TreeRewriter are not for the same source_buffer&#39;</span> <span class="ruby-keyword">unless</span>
    <span class="ruby-identifier">source_buffer</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">with</span>.<span class="ruby-identifier">source_buffer</span>

  <span class="ruby-ivar">@action_root</span> = <span class="ruby-ivar">@action_root</span>.<span class="ruby-identifier">combine</span>(<span class="ruby-identifier">with</span>.<span class="ruby-identifier">action_root</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-process" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">process</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Applies all scheduled changes to the ‘source_buffer` and returns modified source as a new string.</p>

<p>@return [String]</p>

          <div class="method-source-code" id="process-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process</span>
  <span class="ruby-identifier">source</span>     = <span class="ruby-ivar">@source_buffer</span>.<span class="ruby-identifier">source</span>

  <span class="ruby-identifier">chunks</span> = []
  <span class="ruby-identifier">last_end</span> = <span class="ruby-value">0</span>
  <span class="ruby-ivar">@action_root</span>.<span class="ruby-identifier">ordered_replacements</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">range</span>, <span class="ruby-identifier">replacement</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">chunks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">source</span>[<span class="ruby-identifier">last_end</span><span class="ruby-operator">...</span><span class="ruby-identifier">range</span>.<span class="ruby-identifier">begin_pos</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">replacement</span>
    <span class="ruby-identifier">last_end</span> = <span class="ruby-identifier">range</span>.<span class="ruby-identifier">end_pos</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">chunks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">source</span>[<span class="ruby-identifier">last_end</span><span class="ruby-operator">...</span><span class="ruby-identifier">source</span>.<span class="ruby-identifier">length</span>]
  <span class="ruby-identifier">chunks</span>.<span class="ruby-identifier">join</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-remove" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">remove</span><span
            class="method-args">(range)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Shortcut for ‘replace(range, ”)`</p>

<p>@param [Range] range @return [Rewriter] self @raise [ClobberingError] when clobbering is detected</p>

          <div class="method-source-code" id="remove-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove</span>(<span class="ruby-identifier">range</span>)
  <span class="ruby-identifier">replace</span>(<span class="ruby-identifier">range</span>, <span class="ruby-string">&#39;&#39;</span>.<span class="ruby-identifier">freeze</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-replace" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">replace</span><span
            class="method-args">(range, content)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Replaces the code of the source range ‘range` with `content`.</p>

<p>@param [Range] range @param [String] content @return [Rewriter] self @raise [ClobberingError] when clobbering is detected</p>

          <div class="method-source-code" id="replace-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">content</span>)
  <span class="ruby-identifier">combine</span>(<span class="ruby-identifier">range</span>, <span class="ruby-value">replacement:</span> <span class="ruby-identifier">content</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-transaction" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">transaction</span><span
            class="method-args">() { || ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Provides a protected block where a sequence of multiple rewrite actions are handled atomically. If any of the actions failed by clobbering, all the actions are rolled back. Transactions can be nested.</p>

<p>@raise [RuntimeError] when no block is passed</p>

          <div class="method-source-code" id="transaction-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 310</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transaction</span>
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;#{self.class}##{__method__} requires block&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">previous</span> = <span class="ruby-ivar">@in_transaction</span>
  <span class="ruby-ivar">@in_transaction</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-identifier">restore_root</span> = <span class="ruby-ivar">@action_root</span>

  <span class="ruby-keyword">yield</span>

  <span class="ruby-identifier">restore_root</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">ensure</span>
  <span class="ruby-ivar">@action_root</span> = <span class="ruby-identifier">restore_root</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">restore_root</span>
  <span class="ruby-ivar">@in_transaction</span> = <span class="ruby-identifier">previous</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-wrap" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">wrap</span><span
            class="method-args">(range, insert_before, insert_after)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Inserts the given strings before and after the given range.</p>

<p>@param [Range] range @param [String, nil] <a href="TreeRewriter.html#method-i-insert_before"><code>insert_before</code></a> @param [String, nil] <a href="TreeRewriter.html#method-i-insert_after"><code>insert_after</code></a> @return [Rewriter] self @raise [ClobberingError] when clobbering is detected</p>

          <div class="method-source-code" id="wrap-source">
            <pre><span class="ruby-comment"># File vendor/bundle/ruby/3.1.0/gems/parser-3.1.1.0/lib/parser/source/tree_rewriter.rb, line 206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wrap</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">insert_before</span>, <span class="ruby-identifier">insert_after</span>)
  <span class="ruby-identifier">combine</span>(<span class="ruby-identifier">range</span>, <span class="ruby-value">insert_before:</span> <span class="ruby-identifier">insert_before</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-value">insert_after:</span> <span class="ruby-identifier">insert_after</span>.<span class="ruby-identifier">to_s</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

